# venv-selector.nvim

PEP-723 inline script metadata support.

## Goal

Make venv-selector.nvim detect PEP-723 inline dependencies and activate the correct uv-managed venv so pyright resolves imports.

## Test Files

- `ctest/app.py` - PEP-723 test script
- `ctest/diag.lua` - headless diagnostic check
- `ctest/lspinfo.lua` - headless LSP config inspection

## LSP Gate Flow

The plugin intercepts `vim.lsp.start` to ensure Python LSPs start with the correct venv.

### Gate Installation (init.lua:gate_lsp_start)

During `setup()`, the plugin wraps `vim.lsp.start`:

```lua
local orig_start = vim.lsp.start
rawset(vim.lsp, "start", function(config, opts) ... end)
```

### When vim.lsp.start Is Called

The gate checks:
1. If NOT a Python buffer (`vim.bo[bufnr].filetype ~= "python"`) -> pass through to `orig_start()`
2. If `vim.g.venv_selector_activated == true` -> pass through to `orig_start()`
3. Otherwise: queue the config, call `start_activation_once()`, return `nil` (blocks LSP)

### start_activation_once()

1. Sets a 2-second safety timer (prevents infinite blocking if activation hangs)
2. Calls `cached_venv.handle_automatic_activation()` with a callback
3. Callback calls `done_fail_open()` which sets `vim.g.venv_selector_activated = true` and calls `flush()`

### cached_venv.retrieve()

1. Checks for PEP-723 buffer via `uv2.is_uv_buffer()`
   - If PEP-723: skips cache, returns `finish(false)` (no venv activated)
   - If NOT PEP-723: looks up cached venv for CWD, activates if found
2. Calls completion callback

### venv.activate()

1. Sets `path.current_python_path`, `path.current_venv_path`, `path.current_type`
2. Runs all registered hooks (including `dynamic_python_lsp_hook`)
3. Updates shell PATH/VIRTUAL_ENV
4. Sets `vim.g.venv_selector_activated = true`

### flush()

Calls `orig_start()` for all queued configs:

```lua
for _, it in ipairs(items) do
    orig_start(it.config, it.opts)
end
```

### Sequence Diagram

```
vim.lsp.start(python_lsp)
    |
    v
Gate: is Python buffer? ---No--> orig_start()
    | Yes
    v
Gate: activated? ---Yes--> orig_start()
    | No
    v
Queue config, start_activation_once()
    |
    v
cached_venv.retrieve()
    |
    +-- PEP-723? --Yes--> skip cache, finish(false)
    |
    +-- Regular? -> load cache -> venv.activate()
                                    |
                                    v
                              hooks restart LSPs
                              vim.g.venv_selector_activated = true
                                    |
                                    v
                              flush() -> orig_start() for all queued
```

### Key Points

- **Blocking**: Gate returns `nil` to block LSP until venv resolved
- **Safety timer**: 2s timeout prevents infinite blocking
- **Hooks layer**: If LSP already running, hooks stop and restart with new config (250ms defer)

## Debugging

```bash
# Check diagnostics
cd ctest && nvim --headless -c 'luafile diag.lua' app.py 2>&1

# Check LSP config
cd ctest && nvim --headless -c 'luafile lspinfo.lua' app.py 2>&1

# Check logs in nvim
:VenvSelectLog

# Trace log (generated by trace.lua module)
cat ctest/trace.log
```

## Race Condition Analysis (2026-02-12)

### Observed Behavior

With PEP-723 buffer `app.py`, basedpyright gets `/usr/bin/python` while ruff gets the correct uv venv python.

### Root Cause: Different root_dir Detection Speed

lspconfig's `root_dir` function runs before calling `vim.lsp.start()`. The two LSPs have different detection complexity:

**ruff** (fast - 3 patterns):
```lua
-- ~/.local/share/nvim/lazy/nvim-lspconfig/lua/lspconfig/configs/ruff.lua
root_dir = function(fname)
  return util.root_pattern('pyproject.toml', 'ruff.toml', '.ruff.toml')(fname)
    or vim.fs.dirname(vim.fs.find('.git', { path = fname, upward = true })[1])
end
```

**basedpyright** (slow - 7 patterns checked sequentially):
```lua
-- ~/.local/share/nvim/lazy/nvim-lspconfig/lua/lspconfig/configs/basedpyright.lua
local root_files = {
  'pyproject.toml', 'setup.py', 'setup.cfg', 'requirements.txt',
  'Pipfile', 'pyrightconfig.json', '.git',
}
root_dir = function(fname)
  return util.root_pattern(unpack(root_files))(fname)
end
```

This means ruff's `vim.lsp.start()` is called before basedpyright's, so ruff gets queued while basedpyright arrives after the gate releases.

### Trace Log

```
=== TRACE START Wed 11 Feb 2026 02:45:22 PM EST ===
[14:45:22] GATE: name=copilot bufnr=nil ft=? activated=false started=false caller=.../copilot.lua/lua/copilot/client/init.lua:159
[14:45:22] GATE: PASS (invalid bufnr)
[14:45:22] UV2: ensure_uv_buffer_activated bufnr=1
[14:45:22] UV2: last_python=nil current=nil
[14:45:22] GATE: name=ruff bufnr=1 ft=python activated=false started=false caller=.../nvim-lspconfig/lua/lspconfig/manager.lua:130
[14:45:22] GATE: QUEUE ruff
[14:45:22] CACHED_VENV: bufnr=1 is_uv=true
[14:45:22] CACHED_VENV: finish activated=false
[14:45:22] ACTIVATION: done_fail_open queued=1
[14:45:22] FLUSH: 1 configs queued
[14:45:22] GATE: name=basedpyright bufnr=1 ft=python activated=true started=false caller=.../nvim-lspconfig/lua/lspconfig/manager.lua:130
[14:45:22] GATE: PASS (activated)
[14:45:22] GATE: name=ruff bufnr=1 ft=python activated=true started=false caller=.../nvim-lspconfig/lua/lspconfig/manager.lua:130
[14:45:22] GATE: PASS (activated)
[14:45:22] GATE: name=basedpyright bufnr=1 ft=python activated=true started=false caller=.../nvim-lspconfig/lua/lspconfig/manager.lua:130
[14:45:22] GATE: PASS (activated)
[14:45:22] FLUSH: starting ruff bufnr=1 settings.python="nil"
[14:45:22] UV2: python_find result=/home/sridhar/.cache/uv/environments-v2/app-2691540843c6d2fe/bin/python3 current=nil
[14:45:22] UV2: activating python_path=/home/sridhar/.cache/uv/environments-v2/app-2691540843c6d2fe/bin/python3
[14:45:22] HOOKS: restart_all_python_lsps python=/home/sridhar/.cache/uv/environments-v2/app-2691540843c6d2fe/bin/python3 type=uv
[14:45:22] HOOKS: checking client ruff fts={ "python" }
[14:45:22] HOOKS: IS python LSP: ruff
[14:45:22] HOOKS: restarting ruff old_python=nil new_python="/home/sridhar/.cache/uv/environments-v2/app-2691540843c6d2fe/bin/python3"
[14:45:22] GATE: name=ruff bufnr=1 ft=python activated=true started=false caller=.../venv-selector.nvim/lua/venv-selector/hooks.lua:182
[14:45:22] GATE: PASS (activated)
```

### Key Observations

1. **lspconfig calls vim.lsp.start multiple times per LSP**
   - All calls originate from `lspconfig/manager.lua:130`
   - ruff: 3 calls (1 queued, 2 pass-through)
   - basedpyright: 2 calls (both pass-through)

2. **Gate releases too early for PEP-723 buffers**
   - `cached_venv.retrieve()` detects PEP-723 → immediately calls `finish(false)`
   - `done_fail_open()` sets `activated=true` with only 1 config queued (ruff)
   - basedpyright's first call arrives AFTER `activated=true` is set

3. **Timeline breakdown**
   ```
   T0: copilot arrives (no bufnr) → pass
   T1: UV2.ensure_uv_buffer_activated runs (from BufEnter autocmd)
   T2: ruff arrives (activated=false) → QUEUED
   T3: cached_venv detects PEP-723 → finish(false)
   T4: done_fail_open sets activated=true, queued=1
   T5: FLUSH scheduled (vim.schedule)
   T6: basedpyright arrives (activated=true) → PASS (no venv!)
   T7: ruff arrives again (activated=true) → PASS
   T8: basedpyright arrives again (activated=true) → PASS
   T9: FLUSH executes: starts queued ruff (no venv settings)
   T10: UV flow completes, finds python path
   T11: venv.activate() → restart_all_python_lsps()
   T12: HOOKS only finds ruff as active client (basedpyright not ready yet)
   T13: ruff restarted with correct venv
   ```

4. **Why basedpyright is not restarted**
   - At T11-T12, basedpyright hasn't fully initialized as an LSP client
   - `vim.lsp.get_clients()` only returns ruff
   - basedpyright passed through gate but hasn't registered yet

5. **Why lspconfig calls start() multiple times**
   - Multiple autocmds trigger: FileType, BufReadPost, etc.
   - lspconfig's manager retries attachment on various events
   - This is normal lspconfig behavior

### Additional Findings (with client ID tracing)

**Client IDs returned by vim.lsp.start:**
```
copilot: 1
basedpyright (1st): 2
ruff (pass-through): 3
basedpyright (2nd): 2 (reused)
FLUSH ruff: 3 (reused)
ruff (hooks restart): 4
```

**Why lspconfig calls start() multiple times:**
- When gate returns `nil`, lspconfig doesn't get a client ID, so it retries
- Second calls returning same IDs are vim.lsp.start's `reuse_client` logic
- This is expected behavior

**Critical finding - vim.lsp.get_clients() at restart time:**
```
HOOKS: vim.lsp.get_clients() returned 1 clients
HOOKS: client id=3 name=ruff fts={ "python" } attached_bufs={ 1 }
```

**basedpyright (id=2) is NOT in the client list!**

Even though `vim.lsp.start` returned id=2 for basedpyright, by the time `restart_all_python_lsps` runs:
- copilot (id=1) - not in list
- basedpyright (id=2) - not in list
- ruff (id=3) - present and attached

**Root cause:** The UV flow completes faster than basedpyright's server startup. Sequence:
1. UV commands run async (`vim.system`)
2. UV completes, calls `venv.activate()` → `restart_all_python_lsps()`
3. At this moment, basedpyright server is still initializing
4. `vim.lsp.get_clients()` only returns fully-initialized clients
5. Only ruff has finished initializing

### Summary

Two factors combine to cause the race:

1. **Late arrival at gate** - basedpyright's `vim.lsp.start()` is called AFTER `activated=true` because its `root_dir` detection takes longer (7 files vs 3).

2. **Not in client list when hooks run** - Even after passing through the gate, basedpyright hasn't fully initialized by the time `restart_all_python_lsps()` calls `vim.lsp.get_clients()`.

### Config Files (AstroNvim + astrocommunity)

- `~/.config/nvim/lua/community.lua` - imports astrocommunity packs
- `~/.local/share/nvim/lazy/astrocommunity/lua/astrocommunity/pack/python/init.lua` - basedpyright
- `~/.local/share/nvim/lazy/astrocommunity/lua/astrocommunity/pack/python-ruff/init.lua` - ruff
- `~/.local/share/nvim/lazy/nvim-lspconfig/lua/lspconfig/configs/basedpyright.lua` - 7-file root search
- `~/.local/share/nvim/lazy/nvim-lspconfig/lua/lspconfig/configs/ruff.lua` - 3-file root search

### Open Questions

- Should the gate wait for UV resolution before releasing for PEP-723 buffers?
- How to handle LSPs that initialize slower than the UV flow?
- Should restart_all_python_lsps be deferred or retried?
